#include <iostream>
using namespace std;

//int dp[]
//10억은 저장할 수도 없는데...
//dp로도 못 푸는 문제..?

/*
dp 생각에 빠져서.. 문제 보자마자 dp밖에 생각이 안나서 이렇게 풀었는데.
배열.. 10억 이상을 넣을 수 없다는 걸 알게됐다.
그래서 이 문제는 dp로 푸는 것도 아니었던 것이다.

다시 찾아보니, 시간복잡도 O(N)에 공간복잡도 O(1) 만에 푸는 방법이 있었다.
k움직일 때 k만큼의 비용이 발생하는 것과
2배를 움직인다는 점에서 풀 수 있는 이유가 되는 것 같더라.
엄청 짧음.

int answer=0;
while(n!=0) {
  if(n%2==0) {
    n= n/2;
  }
  else {
    n = n-1;
    answer++;
  }
}

이게 끝이다.
2배로 점프할 때는 비용이 발생하지 않고
2배 점프해서 만들어지는 수가 아닌 수라면
1 뒤로 가게 하고.. 비용 1 증가하고....

이런식으로 0까지 가면 비용이 구해진다.
*/

int d[10000000001];

int solution(int n)
{
    int ans = 0;

    d[1] =1;
    for(int i=2;i<=n;i++) {
        d[i] =i;
        for(int k=1;k<=i;k++) {
            d[i] = min(d[i], d[i-k]+k);
        }
        if(i%2==0) {
            d[i] = min(d[i], d[i/2]);
        }
    }

    ans = d[n];
    
    return ans;
}
